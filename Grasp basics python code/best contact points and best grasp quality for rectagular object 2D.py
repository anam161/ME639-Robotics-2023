# -*- coding: utf-8 -*-
"""Untitled30.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VuOdwUCz2uDLJZxEGL-OyL5DmvnVkIY4
"""

import numpy as np
import itertools

def generate_candidate_contact_points_2d(length, width):
    # Define corners of the rectangle
    corners = [
        (0, 0),         # Bottom-left corner
        (length, 0),    # Bottom-right corner
        (0, width),     # Top-left corner
        (length, width) # Top-right corner
    ]

    # Define midpoints of the edges
    edges_midpoints = [
        (length / 2, 0),      # Midpoint of bottom edge
        (length / 2, width),  # Midpoint of top edge
        (0, width / 2),       # Midpoint of left edge
        (length, width / 2)   # Midpoint of right edge
    ]

    # Combine corners and edges midpoints
    candidate_points = corners + edges_midpoints

    return candidate_points

def form_grasp_matrix(p1, p2):
    x1, y1 = p1
    x2, y2 = p2

    # Assume surface normals are perpendicular to the edges of the rectangle
    # Assuming the rectangle is aligned with the coordinate axes
    if x1 == 0 or x1 == length:
        n1 = np.array([1, 0])
    else:
        n1 = np.array([0, 1])

    if x2 == 0 or x2 == length:
        n2 = np.array([1, 0])
    else:
        n2 = np.array([0, 1])

    # Construct the grasp matrix for the pair of points
    G = np.array([
        [n1[0], n1[1], x1 * n1[1] - y1 * n1[0]],
        [n2[0], n2[1], x2 * n2[1] - y2 * n2[0]]
    ])

    return G

def compute_grasp_quality(G):
    try:
        # Compute the singular values of the grasp matrix
        _, s, _ = np.linalg.svd(G)
        # The quality of the grasp can be related to the minimum singular value
        quality = np.min(s)
        return quality
    except np.linalg.LinAlgError:
        # In case of a singular matrix, return a low quality value
        return 0

def evaluate_contact_points(candidate_points):
    best_quality = 0
    best_combination = None

    # Generate all pairs of candidate points
    for p1, p2 in itertools.combinations(candidate_points, 2):
        G = form_grasp_matrix(p1, p2)
        quality = compute_grasp_quality(G)

        if quality > best_quality:
            best_quality = quality
            best_combination = (p1, p2)

    return best_combination, best_quality

# Example dimensions of the 2D rectangle
length = 10
width = 5

candidate_points_2d = generate_candidate_contact_points_2d(length, width)
best_combination, best_quality = evaluate_contact_points(candidate_points_2d)

print("Best Contact Points Combination:", best_combination)
print("Best Grasp Quality:", best_quality)





