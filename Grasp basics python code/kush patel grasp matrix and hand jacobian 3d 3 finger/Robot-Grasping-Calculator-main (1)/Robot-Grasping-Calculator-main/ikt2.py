# -*- coding: utf-8 -*-
"""Untitled76.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13lZIT6JWood_mFghOlHDleFotLjHCyAu
"""

import mujoco_py
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# Inverse kinematics for a planar 2-DOF manipulator
def compute_ik(target_x, target_y, link1_length, link2_length):
    D = (target_x**2 + target_y**2 - link1_length**2 - link2_length**2) / (2 * link1_length * link2_length)
    D = np.clip(D, -1, 1)
    theta2 = np.arctan2(np.sqrt(1 - D**2), D)
    theta1 = np.arctan2(target_y, target_x) - np.arctan2(link2_length * np.sin(theta2), link1_length + link2_length * np.cos(theta2))
    return theta1, theta2

# Function to compute Jacobian matrix for a 2-DOF manipulator
def compute_jacobian(theta1, theta2, link1_length, link2_length):
    J = np.array([
        [-link1_length * np.sin(theta1) - link2_length * np.sin(theta1 + theta2), -link2_length * np.sin(theta1 + theta2)],
        [link1_length * np.cos(theta1) + link2_length * np.cos(theta1 + theta2),  link2_length * np.cos(theta1 + theta2)]
    ])
    return J

# Define link lengths
link1_length = 1.732
link2_length = 1

# Target point for the end-effector to reach
target_x = -0.2
target_y = 2

# Compute joint angles based on the target
theta1, theta2 = compute_ik(target_x, target_y, link1_length, link2_length)
print(f"Computed joint angles to reach target ({target_x}, {target_y}): theta1={theta1:.4f}, theta2={theta2:.4f}")

# Initialize the Mujoco simulation
xml_path = "/home/linux/Documents/mujoco200_linux/project (B)/2r(B).xml"
model = mujoco_py.load_model_from_path(xml_path)
sim = mujoco_py.MjSim(model)

# Set initial joint positions based on IK calculation
sim.data.qpos[0] = theta1
sim.data.qpos[1] = theta2
initial_position = np.copy(sim.data.qpos[:2])  # Store initial position

# Create the viewer
viewer = mujoco_py.MjViewer(sim)

# Force sensor readings storage for live plot
force_readings = []
step_counter = []

# Prepare a live plot with matplotlib
plt.ion()  # Interactive mode for live updates
fig, ax = plt.subplots()
ax.set_xlim(0, 5000)  # x-axis range (simulation steps)
ax.set_ylim(-500, 500)  # y-axis range (force values)
line, = ax.plot([], [], lw=2)

# Force applied to the end-effector
force = np.array([-500, 0])  # Example force in the x and y direction at the end-effector

# Control parameters for the sequence of operations
cycles = 5  # Number of cycles
steps_per_action = 200  # Steps for each action phase
steps_pause = 100  # Steps to pause at the initial position

# Simulation control variables
current_cycle = 0
current_state = 'idle'  # States: 'apply_force', 'return_initial', 'pause'
steps_in_current_state = 0
positions = []
ik_reached = False
pause_steps = 0
max_pause_steps = 1000
steps_after_ik = 0

def update_plot():
    """Update the force graph dynamically."""
    line.set_xdata(step_counter)
    line.set_ydata(force_readings)
    fig.canvas.draw()
    fig.canvas.flush_events()

def apply_force(sim, force):
    """Apply force using Jacobian transpose."""
    theta1_current = sim.data.qpos[0]
    theta2_current = sim.data.qpos[1]
    J = compute_jacobian(theta1_current, theta2_current, link1_length, link2_length)
    tau = J.T @ force
    sim.data.ctrl[0] = tau[0]
    sim.data.ctrl[1] = tau[1]
    print("Applying force torques (τ):", tau)

def reset_to_initial_position(sim, initial_position):
    """Move joints back to the initial position."""
    sim.data.qpos[0] = initial_position[0]
    sim.data.qpos[1] = initial_position[1]
    sim.data.ctrl[0] = 0
    sim.data.ctrl[1] = 0
    print("Returning to initial position:", initial_position)

# Simulation loop
while current_cycle < cycles or (ik_reached and steps_after_ik < 5000):
    if current_state == 'idle':
        # Idle state to transition to force application
        current_state = 'apply_force'
        steps_in_current_state = 0

    elif current_state == 'apply_force':
        # Apply force for a certain number of steps
        if steps_in_current_state < steps_per_action:
            apply_force(sim, force)
            steps_in_current_state += 1
        else:
            # Transition to return to initial position
            current_state = 'return_initial'
            steps_in_current_state = 0

    elif current_state == 'return_initial':
        # Return to the initial position
        if steps_in_current_state < steps_per_action:
            reset_to_initial_position(sim, initial_position)
            steps_in_current_state += 1
        else:
            # Transition to pause state
            current_state = 'pause'
            steps_in_current_state = 0

    elif current_state == 'pause':
        # Pause at the initial position
        if steps_in_current_state < steps_pause:
            reset_to_initial_position(sim, initial_position)
            steps_in_current_state += 1
        else:
            # Completed a cycle, transition to next force application or end
            current_cycle += 1
            current_state = 'apply_force'
            steps_in_current_state = 0

    # Update IK-based positioning if not already reached
    if not ik_reached:
        # Step 1: Move to target point using IK
        theta1, theta2 = compute_ik(target_x, target_y, link1_length, link2_length)
        sim.data.qpos[0] = theta1
        sim.data.qpos[1] = theta2
        print("Moving to target using IK:", sim.data.qpos[:2])
        if np.allclose([sim.data.qpos[0], sim.data.qpos[1]], [theta1, theta2], atol=1e-2):
            print("Reached target point through IK.")
            ik_reached = True
            reached_position = np.copy(sim.data.qpos[:2])

    elif ik_reached and pause_steps < max_pause_steps:
        # Step 2: Pause for a fixed number of simulation steps
        print(f"Pausing... Step {pause_steps}/{max_pause_steps}")
        sim.data.qpos[0] = reached_position[0]
        sim.data.qpos[1] = reached_position[1]
        pause_steps += 1

    elif ik_reached and pause_steps >= max_pause_steps:
        # Step 3: Apply torques based on the external force using Jacobian transpose after pause
        theta1_current = sim.data.qpos[0]
        theta2_current = sim.data.qpos[1]
        # Compute the Jacobian at the current joint angles
        J = compute_jacobian(theta1_current, theta2_current, link1_length, link2_length)
        # Get the position of the specific site and compute the error term
        site_name = "force_sensor"
        site_index = model.site_name2id(site_name)  # Get the index of the site
        site_position = sim.data.site_xpos[site_index]
        print("site position:", site_position)
        y_position = site_position[1]
        positions.append([0, y_position])
        yd = np.array([0, 2])
        Kyy = np.eye(2) * 30
        ey = (yd - positions[-1])

        # Apply joint torques
        tau = J.T @ force + J.T @ (Kyy @ ey)
        sim.data.ctrl[0] = tau[0]
        sim.data.ctrl[1] = tau[1]
        print("Applying torques (τ):", tau)
        print("Current joint positions:", sim.data.qpos[:2])
        # Increment steps after IK to track time passed since torque application started
        steps_after_ik += 1

    # Step the simulation
    sim.step()

    # Render the scene
    viewer.render()

    # Get the force sensor readings for plotting
    sensor_name = "my_force_sensor"
    sensor_index = model.sensor_name2id(sensor_name)
    force_value = sim.data.sensordata[sensor_index]
    print("force_value:", force_value)
    force_readings.append(force_value)
    step_counter.append(len(force_readings))
    if len(force_readings) % 10 == 0:
        update_plot()

# Finalize and show the plot
plt.ioff()
plt.show()