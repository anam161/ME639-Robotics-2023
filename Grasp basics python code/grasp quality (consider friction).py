# -*- coding: utf-8 -*-
"""Untitled30.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VuOdwUCz2uDLJZxEGL-OyL5DmvnVkIY4
"""





import numpy as np
import itertools

def generate_candidate_contact_points_2d(length, width):
    corners = [(0, 0), (length, 0), (0, width), (length, width)]
    edges_midpoints = [(length / 2, 0), (length / 2, width), (0, width / 2), (length, width / 2)]
    candidate_points = corners + edges_midpoints
    return candidate_points

def form_grasp_matrix(p1, p2):
    x1, y1 = p1
    x2, y2 = p2

    if x1 == 0 or x1 == length:
        n1 = np.array([1, 0])
    else:
        n1 = np.array([0, 1])

    if x2 == 0 or x2 == length:
        n2 = np.array([1, 0])
    else:
        n2 = np.array([0, 1])

    G = np.array([
        [n1[0], n1[1], x1 * n1[1] - y1 * n1[0]],
        [n2[0], n2[1], x2 * n2[1] - y2 * n2[0]]
    ])

    return G

def compute_grasp_quality(G):
    try:
        _, s, _ = np.linalg.svd(G)
        quality = np.min(s)
        return quality
    except np.linalg.LinAlgError:
        return 0

def evaluate_contact_points(candidate_points):
    best_quality = 0
    best_combination = None
    qualities = []

    for p1, p2 in itertools.combinations(candidate_points, 2):
        G = form_grasp_matrix(p1, p2)
        quality = compute_grasp_quality(G)
        qualities.append((quality, (p1, p2)))

        if quality > best_quality:
            best_quality = quality
            best_combination = (p1, p2)

    return best_combination, best_quality, qualities

length = 10
width = 5

candidate_points_2d = generate_candidate_contact_points_2d(length, width)
best_combination, best_quality, all_qualities = evaluate_contact_points(candidate_points_2d)

print("Best Contact Points Combination:", best_combination)
print("Best Grasp Quality:", best_quality)

print("\nAll Non-Zero Quality Contact Points:")
for quality, points in sorted(all_qualities, reverse=True):
    if quality > 0:
        print(f"Quality: {quality:.4f}, Points: {points}")

import numpy as np
import itertools

def generate_candidate_contact_points_2d(length, width):
    corners = [(0, 0), (length, 0), (0, width), (length, width)]
    edges_midpoints = [(length / 2, 0), (length / 2, width), (0, width / 2), (length, width / 2)]
    candidate_points = corners + edges_midpoints
    return candidate_points

def form_grasp_matrix_with_friction(p1, p2, mu):
    x1, y1 = p1
    x2, y2 = p2

    # Assume surface normals are perpendicular to the edges of the rectangle
    if x1 == 0 or x1 == length:
        n1 = np.array([1, 0])
    else:
        n1 = np.array([0, 1])

    if x2 == 0 or x2 == length:
        n2 = np.array([1, 0])
    else:
        n2 = np.array([0, 1])

    # Friction cone approximation (linear)
    t1 = mu * np.array([-n1[1], n1[0]])
    t2 = mu * np.array([-n2[1], n2[0]])

    G = np.array([
        [n1[0], n1[1], x1 * n1[1] - y1 * n1[0]],
        [t1[0], t1[1], x1 * t1[1] - y1 * t1[0]],
        [n2[0], n2[1], x2 * n2[1] - y2 * n2[0]],
        [t2[0], t2[1], x2 * t2[1] - y2 * t2[0]]
    ])

    return G

def compute_grasp_quality(G):
    try:
        _, s, _ = np.linalg.svd(G)
        quality = np.min(s)
        return quality
    except np.linalg.LinAlgError:
        return 0

def evaluate_contact_points(candidate_points, mu):
    best_quality = 0
    best_combination = None
    qualities = []

    for p1, p2 in itertools.combinations(candidate_points, 2):
        G = form_grasp_matrix_with_friction(p1, p2, mu)
        quality = compute_grasp_quality(G)
        qualities.append((quality, (p1, p2)))

        if quality > best_quality:
            best_quality = quality
            best_combination = (p1, p2)

    return best_combination, best_quality, qualities

# Example object dimensions and properties
length = 10
width = 5
mu = 0.5  # Friction coefficient

candidate_points_2d = generate_candidate_contact_points_2d(length, width)
best_combination, best_quality, all_qualities = evaluate_contact_points(candidate_points_2d, mu)

print("Best Contact Points Combination:", best_combination)
print("Best Grasp Quality:", best_quality)

print("\nAll Non-Zero Quality Contact Points:")
for quality, points in sorted(all_qualities, reverse=True):
    if quality > 0:
        print(f"Quality: {quality:.4f}, Points: {points}")

