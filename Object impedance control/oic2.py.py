# -*- coding: utf-8 -*-
"""Untitled49.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ndr-FaLUXW4YrxfqA2YOeInpb4hHuZaj
"""

import numpy as np
import mujoco_py

def grasp_matrix_2d(contact_points):
    """
    Constructs a grasp matrix for multiple 2D contact points.

    Parameters:
    contact_points (list of tuples): Each tuple contains (t, n, x) where
        t (np.array): Tangential direction vector at contact point.
        n (np.array): Normal direction vector at contact point.
        x (np.array): Position vector of the contact point.

    Returns:
    np.array: The grasp matrix G.
    """
    G_list = []

    for t, n, x in contact_points:
        t = np.atleast_2d(t).T
        n = np.atleast_2d(n).T
        x = np.atleast_2d(x).T

        G_i = np.block([[t, n], [np.cross(x.T, t.T).T, np.cross(x.T, n.T).T]])
        G_list.append(G_i)

    G = np.hstack(G_list)
    return G

def W(t, n):
    t = np.atleast_2d(t).T
    n = np.atleast_2d(n).T
    w  = np.block([t, n])
    return w

def rotation_matrix_2d(theta):
    R = np.array([[np.cos(theta), -np.sin(theta)],
                  [np.sin(theta), np.cos(theta)]])
    return R

def jacobian(l1, l2, theta1, theta2):
    J = np.array([[-l1*np.sin(theta1), -l2*np.sin(theta2)],
                  [l1*np.cos(theta1), l2*np.cos(theta2)]])
    return J

def hand_jacobian(t, n, w, R, J):
    WRJ = np.dot(np.dot(w, R), J)
    O = np.zeros((2, 2))
    HJ = np.concatenate([WRJ, O], axis=1)
    return HJ

# Contact points for grasp matrix
contact_points = [
    (np.array([0, -1]), np.array([1, 0]), np.array([-2, 0])),
    (np.array([0, -1]), np.array([1, 0]), np.array([2, 0]))
]

G = grasp_matrix_2d(contact_points)

# Example parameters for Jacobian calculation
t1 = np.array([0, -1])
n1 = np.array([1, 0])
theta1 = 120 * (np.pi / 180)
theta2 = np.pi / 6
l1 = 0.866
l2 = 0.5
w1 = W(t1, n1)
R1 = rotation_matrix_2d(0)
J1 = jacobian(l1, l2, theta1, theta2)
HJR1 = hand_jacobian(t1, n1, w1, R1, J1)

t2 = np.array([0, 1])
n2 = np.array([-1, 0])
w2 = W(t2, n2)
R2 = rotation_matrix_2d(0)
J2 = jacobian(l1, l2, theta1, theta2)
HJR2 = hand_jacobian(t2, n2, w2, R2, J2)

Hand_jacobian = np.concatenate([HJR1, HJR2], axis=0)
Jh = Hand_jacobian

# Load the Mujoco model
model = mujoco_py.load_model_from_path("/home/linux/Documents/mujoco200_linux/grasp/manipulator45.xml")
sim = mujoco_py.MjSim(model)

# Define controller gains
Kp = np.array([20, 20, 20])
Kd = np.array([20, 20, 20])

# Desired positions and velocities (example values)
Xd = np.array([0, 0.2, 0])
Vd = np.array([0, 0.1, 0])

# Initialize the simulation
sim_state = sim.get_state()
sim.set_state(sim_state)
sim.forward()

# Initialize the viewer
viewer = mujoco_py.MjViewer(sim)

# Simulation loop
for i in range(1000):
    # Get the current state
    X = sim.data.qpos[:3]
    V = sim.data.qvel[:3]

    # Calculate forces
    f = G.T @ (Kp * (Xd - X) + Kd * (Vd - V))

    # Calculate joint torques
    joint_torques = Jh.T @ f

    # Apply torques to the actuators
    sim.data.ctrl[:] = joint_torques

    # Step the simulation
    sim.step()

    # Render the simulation
    viewer.render()

# After simulation, you can analyze the results