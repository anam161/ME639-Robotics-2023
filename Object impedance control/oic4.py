# -*- coding: utf-8 -*-
"""Untitled50.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1njCg6g8Tz9fT1B8lQsxPCukrjvx3hFpw
"""

import numpy as np
import mujoco_py
import time

def grasp_matrix_2d(contact_points):
    """
    Constructs a grasp matrix for multiple 2D contact points.

    Parameters:
    contact_points (list of tuples): Each tuple contains (t, n, x) where
        t (np.array): Tangential direction vector at contact point.
        n (np.array): Normal direction vector at contact point.
        x (np.array): Position vector of the contact point.

    Returns:
    np.array: The grasp matrix G.
    """
    G_list = []

    for t, n, x in contact_points:
        t = np.atleast_2d(t).T
        n = np.atleast_2d(n).T
        x = np.atleast_2d(x).T

        G_i = np.block([[t, n], [np.cross(x.T, t.T).T, np.cross(x.T, n.T).T]])
        G_list.append(G_i)

    G = np.hstack(G_list)
    return G

# def forward_kinematics(l1, l2, theta1, theta2):
#     """
#     Calculate forward kinematics for a 2-link planar manipulator.

#     Parameters:
#     l1 (float): Length of the first link.
#     l2 (float): Length of the second link.
#     theta1 (float): Joint angle of the first link.
#     theta2 (float): Joint angle of the second link.

#     Returns:
#     (float, float): Position (x, y) of the end-effector.
#     """
#     x = l1 * np.cos(theta1) + l2 * np.cos(theta1 + theta2)
#     y = l1 * np.sin(theta1) + l2 * np.sin(theta1 + theta2)
#     return x,y

# def angle(x,y):
#     phi = np.arctan([x, y])
#     return phi

def W(t, n):
    t = np.atleast_2d(t).T
    n = np.atleast_2d(n).T
    w  = np.block([t, n])
    return w

def rotation_matrix_2d(theta):
    R = np.array([[np.cos(theta), -np.sin(theta)],
                  [np.sin(theta), np.cos(theta)]])
    return R

def jacobian(l1, l2, theta1, theta2):
    J = np.array([[-l1*np.sin(theta1), -l2*np.sin(theta2)],
                  [l1*np.cos(theta1), l2*np.cos(theta2)]])
    return J

def hand_jacobian(t, n, w, R, J):
    WRJ = np.dot(np.dot(w.T, R), J)
    return WRJ

# Contact points for grasp matrix
contact_points = [
    (np.array([0, -1]), np.array([1, 0]), np.array([-0.2, 0])),
    (np.array([0, 1]), np.array([-1, 0]), np.array([0.2, 0]))
]

G = grasp_matrix_2d(contact_points)

# Example parameters for Jacobian calculation for finger 1
t1 = np.array([0, -1])
n1 = np.array([1, 0])
theta1_1 = -1.047  # theta1 for finger 1
theta2_1 =-1.57 # theta2 for finger 1
l1 = 1.732
l2 = 1
w1 = W(t1, n1)
R1 = rotation_matrix_2d(0)
J1 = jacobian(l1, l2, theta1_1, theta2_1)
HJR1 = hand_jacobian(t1, n1, w1, R1, J1)

# Example parameters for Jacobian calculation for finger 2
t2 = np.array([0, -1])
n2 = np.array([-1, 0])
theta1_2 = 1.047# theta1 for finger 2
theta2_2 = 1.57  # theta2 for finger 2
w2 = W(t2, n2)
R2 = rotation_matrix_2d(0)
J2 = jacobian(l1, l2, theta1_2, theta2_2)
HJR2 = hand_jacobian(t2, n2, w2, R2, J2)

# Adjusting HJR2 to the correct position in the full Jacobian
O = np.zeros((2, 2))
HJR1_full = np.concatenate([HJR1, O], axis=1)
HJR2_full = np.concatenate([O, HJR2], axis=1)

Hand_jacobian = np.concatenate([HJR1_full, HJR2_full], axis=0)
Jh = Hand_jacobian

print("Hand Jacobian:")
print(Jh)

# Load the Mujoco model
model = mujoco_py.load_model_from_path("/home/linux/Documents/mujoco200_linux/grasp/manipulator45.xml")
sim = mujoco_py.MjSim(model)




# # Define controller gains
# Kp =50*np.eye(3)
# # Kd = np.array([10, 10, 10])

# # Desired positions and velocities
# Xd = np.array([0, 0, 0])
# Vd = np.array([0, 0, 0])

# Initialize the simulation
sim_state = sim.get_state()
sim.set_state(sim_state)
sim.forward()

# Initialize the viewer
viewer = mujoco_py.MjViewer(sim)

for _ in range(1000):
    sim.step()
    viewer.render()

# Simulation loop

# for i in range(10000):
#     # Get the current state (object's current position)
#     X = sim.data.get_body_xpos('object')

#     # # Get current joint positions if needed
#     # q = sim.data.qpos

#     # # Assuming the first four values are relevant to the fingers:
#     # theta1_1, theta2_1 = q[0], q[1]  # Joint angles for finger 1
#     # theta1_2, theta2_2 = q[2], q[3]  # Joint angles for finger 2

#     # Recompute the Jacobian for each finger
#     J1 = jacobian(l1, l2, theta1_1, theta2_1)
#     J2 = jacobian(l1, l2, theta1_2, theta2_2)

#     HJR1 = hand_jacobian(t1, n1, w1, R1, J1)
#     HJR2 = hand_jacobian(t2, n2, w2, R2, J2)

#     # Adjusting HJR2 to the correct position in the full Jacobian
#     HJR1_full = np.concatenate([HJR1, O], axis=1)
#     HJR2_full = np.concatenate([O, HJR2], axis=1)

#     Hand_jacobian = np.concatenate([HJR1_full, HJR2_full], axis=0)
#     Jh = Hand_jacobian
#     print(Jh)

#     # Calculate forces
#     N = np.array([1, 1, 1, 1])
#     f_control = G.T @ (Kp @ (Xd - X))
#     GGT = G.T @ G
#     f_nullspace = (np.eye(4) - GGT) @ N

#     # Compute the total force
#     f = f_control + f_nullspace

#     # Calculate joint torques
#     joint_torques = Jh.T @ f

#     # Apply torques to the actuators
#     sim.data.ctrl[:] = joint_torques
#      # Print relevant information every 100 steps
#     if i % 100 == 0:
#         print(f"Step: {i}")
#         print(f"Position (X): {X}")
#         print(f"Force (f): {f}")
#         print(f"Joint Torques: {joint_torques}")

#     # Apply external force to the object
#     if 1500 <= i <= 2200:
#         force = np.array([0, 0, 0, 0, 0, 0])  # Example force in the y-direction
#     else:
#         force = np.array([0, 0, 0, 0, 0, 0])
#     sim.data.xfrc_applied[sim.model.body_name2id('object'), :] = force

#     # Step the simulation
#     sim.step()

#     # Retrieve and print the updated position of the object
#     updated_position = sim.data.get_body_xpos('object')
#     print(f"Step: {i}, Updated position (X): {updated_position}")

#     # Render the simulation
#     viewer.render()


