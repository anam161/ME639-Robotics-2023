# -*- coding: utf-8 -*-
"""Untitled62.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vlLij8NwIZW2w1mNO3yqQNQ4kq4zKLNo
"""

import numpy as np
import mujoco_py
from scipy.spatial.transform import Rotation as R

# Load the MuJoCo model
model = mujoco_py.load_model_from_path('/home/linux/Documents/mujoco200_linux/3d 3r/3d 2fing.xml')
sim = mujoco_py.MjSim(model)
viewer = mujoco_py.MjViewer(sim)

def force_vec(s, t, n):
    z = np.column_stack([s, t, n])
    return z

s1 = np.array([0, 1, 0])
t1 = np.array([0, 0, 1])
n1 = np.array([1, 0, 0])
z1 = force_vec(s1, t1, n1)

s2 = np.array([0, 1, 0])
t2 = np.array([0, 0, -1])
n2 = np.array([-1, 0, 0])
z2 = force_vec(s2, t2, n2)

#define function to calculate cross product
def cross_prod(x, vec):
    return np.cross(x, vec)

# Test
x1 = np.array([-0.03, 0, 0])
p1 = cross_prod(x1, s1)
q1 = cross_prod(x1, t1)
r1 = cross_prod(x1, n1)
k = np.column_stack([p1, q1, r1])
G1 = np.concatenate([z1, k])

x2 = np.array([0.03, 0, 0])
p2 = cross_prod(x2, s2)
q2 = cross_prod(x2, t2)
r2 = cross_prod(x2, n2)
l = np.column_stack([p2, q2, r2])

G2 = np.concatenate([z2, l])
G = np.block([G1, G2])
print(G)

#Define the W, rotation_matrix_2d, jacobian, and hand_jacobian functions
def W(s, t, n):
    s = np.array(s).reshape(3, 1)
    t = np.array(t).reshape(3, 1)
    n = np.array(n).reshape(3, 1)
    w = np.hstack([s, t, n])
    return w

def rotation_matrix_3d(theta):
    R = np.array([[np.cos(theta), -np.sin(theta),0],
                  [np.sin(theta), np.cos(theta),0],
                  [0, 0, 1]])
    return R

def jacobian(l1, l2, l3, theta1, theta2, theta3):
    J = np.array([
        [-l1*np.sin(theta1) - l2*np.sin(theta1+theta2) - l3*np.sin(theta1+theta2+theta3),
         -l2*np.sin(theta1+theta2) - l3*np.sin(theta1+theta2+theta3),
         -l3*np.sin(theta1+theta2+theta3)],
        [l1*np.cos(theta1) + l2*np.cos(theta1+theta2) + l3*np.cos(theta1+theta2+theta3),
         l2*np.cos(theta1+theta2) + l3*np.cos(theta1+theta2+theta3),
         l3*np.cos(theta1+theta2+theta3)],
        [0, 0, 0]
    ])
    return J

def hand_jacobian(s,t, n, w, R, J):
    WRJ = np.dot(np.dot(w.T, R), J)
    return WRJ

#Finger 1 parameters
l1_f1, l2_f1, l3_f1 = 0.05, 0.035, 0.05
theta1_f1, theta2_f1, theta3_f1 = -0.7101171, -0.49921741, -0.29316808

# Tangent and normal vectors for finger 1
s1 = np.array([0, 1, 0])
t1 = np.array([0, 0, 1])
n1 = np.array([-1, 0, 0])
w1 = W(s1, t1, n1)

# Rotation matrix for finger 1 (identity)
R1 = rotation_matrix_3d(0)

# Jacobian for finger 1
J1 = jacobian(l1_f1, l2_f1, l3_f1, theta1_f1, theta2_f1, theta3_f1)
HJR1 = hand_jacobian(s1, t1, n1, w1, R1, J1)

# Finger 2 parameters
l1_f2, l2_f2, l3_f2 = 0.05, 0.035, 0.05
theta1_f2, theta2_f2, theta3_f2 = 1.67275521, 0.37638654, 0.27084398

# Tangent and normal vectors for finger 2
s2 = np.array([0, 1, 0])
t2 = np.array([0, 0, -1])
n2 = np.array([-1, 0, 0])
w2 = W(s2, t2, n2)

# Rotation matrix for finger 2 (identity)
R2 = rotation_matrix_3d(0)

# Jacobian for finger 2
J2 = jacobian(l1_f2, l2_f2, l3_f2, theta1_f2, theta2_f2, theta3_f2)
HJR2 = hand_jacobian(s2, t2, n2, w2, R2, J2)

# Adjusting HJR2 to the correct position in the full Jacobian
O = np.zeros((3, 3))
HJR1_full = np.concatenate([HJR1, O], axis=1)
HJR2_full = np.concatenate([O, HJR2], axis=1)

Hand_jacobian = np.concatenate([HJR1_full, HJR2_full], axis=0)
Jh = Hand_jacobian

# Print the final hand Jacobian
print("Hand Jacobian (Jh):",Jh)

G_pinv = np.linalg.pinv(G)
# Get the box position and orientation
box_pos = sim.data.get_body_xpos('box')
box_ori = sim.data.get_body_xquat('box')

# Convert the quaternion to Euler angles (in radians)
r = R.from_quat([box_ori[1], box_ori[2], box_ori[3], box_ori[0]])  # [x, y, z, w]
euler_angles = r.as_euler('xyz', degrees=False)

# Update X with box position and orientation
X = np.concatenate([box_pos, euler_angles])
print("Box Position and Orientation:", X)

Xd = np.array([0, 0, 0, 0, 0, 0])
Kp = np.array([[10, 0, 0, 0, 0, 0],
               [0, 10, 0, 0, 0, 0],
               [0, 0, 10, 0, 0, 0],
               [0, 0, 0, 10, 0, 0],
               [0, 0, 0, 0, 10, 0],
               [0, 0, 0, 0, 0, 10]])
N = np.array([0.2, 0.2, 0.2, 0.2, 0.2, 0.2])

# Calculate forces
f_control = G_pinv @ (Kp @ (Xd - X))
f_nullspace = (np.eye(6) - G_pinv @ G) @ N
f = f_control + f_nullspace
print(f)

tau_initial = Jh.T @ f
print("torque:",tau_initial)


# Get the box position and orientation
box_pos = sim.data.get_body_xpos('box')
box_ori = sim.data.get_body_xquat('box')

# Convert the quaternion to Euler angles (in radians)
r = R.from_quat([box_ori[1], box_ori[2], box_ori[3], box_ori[0]])  # [x, y, z, w]
euler_angles = r.as_euler('xyz', degrees=False)

# Update X with box position and orientation
X = np.concatenate([box_pos, euler_angles])
print("Box Position and Orientation:", X)

# Specify the names of the joints you're interested in
joint_names = ['1', '3', '4', '5', '7', '8']

# Get the indices of these joints in the qpos array
joint_indices = [model.get_joint_qpos_addr(name) for name in joint_names]

print(joint_indices)

# Get the joint angles
joint_angles = sim.data.qpos[joint_indices].copy()
# print("initial joint angles:",joint_angles)

# Get joint IDs for the corresponding joint names
joint_ids = [sim.model.joint_name2id(name) for name in joint_names]

# Forward the simulation state to apply changes
sim.forward()

palm_id = model.body_name2id('palm_lower')
print(f"Palm ID: {palm_id}")


# Initialize the simulation loop
step_counter = 0

while True:
    # Increment step counter
    step_counter += 1

    # Apply the precomputed torque before 8000 simulation steps
    if step_counter < 6000:
        # Apply the precomputed torque to each joint
        for i, joint_id in enumerate(joint_ids):
            sim.data.ctrl[i] = tau_initial[i]

            # Get the joint angles
            joint_angles = sim.data.qpos[joint_indices].copy()
            # print("initial joint angles:",joint_angles)



    # Apply external force and calculate torque during 8000 to 9000 simulation steps
    elif 6000 <= step_counter <= 6200:
        force_vector = np.array([0, 0, 0])  # Example force vector in the x direction
        torque_vector = np.array([0, 0, 0.55])  # Torque applied
        external_force = np.concatenate([force_vector, torque_vector])

        # Apply the external force to the object (box)
        sim.data.xfrc_applied[model.body_name2id('box')] = external_force

        # Get the current joint angles from the simulation
        joint_angles = sim.data.qpos[joint_indices].copy()
        print("joint angles:", joint_angles)

        theta1_f1, theta2_f1, theta3_f1 = joint_angles[0:3]
        theta1_f2, theta2_f2, theta3_f2 = joint_angles[3:6]

        # Recalculate the Jacobian for each finger
        J1 = jacobian(l1_f1, l2_f1, l3_f1, theta1_f1, theta2_f1, theta3_f1)
        HJR1 = hand_jacobian(s1, t1, n1, w1, R1, J1)

        J2 = jacobian(l1_f2, l2_f2, l3_f2, theta1_f2, theta2_f2, theta3_f2)
        HJR2 = hand_jacobian(s2, t2, n2, w2, R2, J2)

        # Update the full hand Jacobian
        HJR1_full = np.concatenate([HJR1, O], axis=1)
        HJR2_full = np.concatenate([O, HJR2], axis=1)
        Hand_jacobian = np.concatenate([HJR1_full, HJR2_full], axis=0)
        Jh = Hand_jacobian

        # Calculate forces
        f_control = G_pinv @ (Kp @ (Xd - X))
        f_nullspace = (np.eye(6) - G_pinv @ G) @ N
        f = f_control + f_nullspace

        # Recalculate the torque
        tau = Jh.T @ f

        # Apply the calculated torque to each joint
        for i, joint_id in enumerate(joint_ids):
            sim.data.ctrl[i] = tau[i]

            joint_angles = sim.data.qpos[joint_indices].copy() 
            print(f"{step_counter} \tjoint angles: {joint_angles}")


    # After 9000 steps, stop applying external force and drive the object back
    elif step_counter > 6100:
        # Ensure no force is applied after 9000 steps
        external_force = np.zeros(6)  # No force or torque applied
        sim.data.xfrc_applied[model.body_name2id('box')] = external_force

        # Apply the initial torque to each joint to bring back to the original state
        for i, joint_id in enumerate(joint_ids):
            sim.data.ctrl[i] = tau_initial[i]

            joint_angles = sim.data.qpos[joint_indices].copy()
            print(f"{step_counter} \tjoint angles: {joint_angles}")


    # Step the simulation
    sim.step()

    # Render the simulation
    viewer.render()